---
layout:     post
title:      AcWing基础算法-数据结构（三）
subtitle:   AcWing基础算法碎碎念
date:       2021-02-28
author:     小熊pink
header-img: img/the-first.png
catalog:   true
tags:
    - AcWing基础算法
---
# 哈希表



## 普通哈希

作用：用O(1)的时间插入一个数，用O(1)的时间查找一个数。

在哈希表中找到合适的下标，插入这个数。重点在寻找下标。

根据存储结构，分为两种方法：

1. 开放寻址法
2. 拉链法

两种方法中，N都要取>=应有的N的第一个质数。代码为：

```c++
for(int i = N;; ++ i)
{
	bool flag = 1;
	for(int j = 2; j * j <= i; ++ j)
	{
		if(i % j == 0)
		{
			flag = 0;
			break;
		}
	}
	if(flag)
	{
		cout << i << endl;
		break;
	}
}
```



### 开放寻址法

**实现**

一般N取原来N的大小的2-3倍。

h[N]：哈希表

可以让null取0x3f3f3f3f，即比10^9大的一个数。则哈希表初始化为memset(h, 0x3f, sizeof h);（引入头文件<cstring>）

**核心操作**

find()：给出合适的下标（值为x或null）

```c++
int find(int x)
{
    int k = (x % N + N) % N;
    while(h[k] != null && h[k] != x) 
    {
        ++ k;
        if(k == N) k = 0;
    }
    return k;
}
```

**操作**

1. 插入

   ```c++
   h[k] = x;
   ```

2. 查找

   ```c++
   if(h[k] == x) puts("Yes");
   else puts("No");
   ```



### 拉链法

**实现**

h[N]：哈希表。表头。初始化为-1。memset(h, -1, sizeof h);（引入头文件<cstring>）

e[N]：下标为k的节点所存储的元素。

ne[N]：下标为k的节点的next指针，指向下一个节点的下标。

idx：可用节点的下标。初始化为0。

**核心操作**

1. insert()

   ```c++
   void insert(int x)
   {
       int k = (x % N + N) % N;
       e[idx] = x;
       ne[idx] = h[k];
       h[k] = idx ++;
   }
   ```

2. find()

   ```c++
   bool find(int x)
   {
       int k = (x % N + N) % N;
       for(int i = h[k]; i != -1; i = ne[i])
       {
           if(e[i] == x) return true;
       }
       return false;
   }
   ```

**操作**

1. 插入

   ```c++
   insert(x);
   ```

2. 查找

   ```c++
   if(find(x)) puts("Yes");
   else puts("No");
   ```



## 字符串哈希

作用：用O(n)的时间处理一个字符串，用O(1)的时间比较任意两段字符串是否相等。

只有KMP才能用的情况：循环字符串，否则字符串哈希比较快。

**实现**

两个规则：

1. 哈希值不能为0，否则可能会使不同字符串哈希值相同。
2. 使用131或13331的进制和2^64的模，默认人品足够好，不同字符串哈希值不同。

h[N]：一个字符串中，以左边第一个字符为开端，从左到右每位字符为截止的子字符串对应的哈希值。下标即为子字符串的长度。(ULL)

p[N]：P^k对应的值。(ULL)

P：进制。通常取为131或13331。（默认该情况下，所有字符串哈希值不同）（const int）

typedef unsigned long long ULL; 取模用2^64 ，则哈希结果直接可用unsigned long long (溢出自动取模)存储。

char str[N]：存储字符串。且直接用其字符的ASCII值当作每个字符对应的值。

**核心操作**

1. 获取任意段的字符串哈希值

   ```C++
   ULL get(int l, int r)
   {
       return h[r] - h[l - 1] * p[r - l + 1];
   }
   ```

2. 预处理字符串

   ```c++
   p[0] = 1;
   for(int i = 1; i <= n; ++ i)
   {
   	p[i] = p[i - 1] * P;
   	h[i] = h[i - 1] * P + str[i];
   }
   ```



**操作**

比较两段字符串是否相等

```c++
if(get(l1, r1) == get(l2, r2)) puts("Yes");
else puts("No");
```



# STL

C++常用容器

size(), empty() 容器都有

clear() 一些容器有



## vector

变长数组，倍增的思想（插入几乎为O(1)，？）

- 初始化：

  - vector<int> a;
  - vector<int> a(3);
  - vector<int> a(3,0);

- size()：容器大小 O(1)

- empty()：是否为空 O(1)

- clear()：清空

- front() / back()

- push_back() / pop_back()

- begin() / end()

- []

- 支持比较运算（按字典序）

  

## string

字符串

- size() / length()

- empty()

- clear()

- +=

- substr()

  - substr(2, 3); 返回从下标为2的字符开始，长度为3的子字符串。若长度超出字符串最后一个字符，则返回到最后一个字符为止。
  - substr(2); 返回从下标为2的字符开始，直到最后一个字符的子字符串。

- c_str()：返回字符串第一个字符的地址。

  

## queue

队列

- size()
- empty()
- push()：向队尾插入一个元素
- front()：返回队头元素
- back()：返回队尾元素
- pop()：弹出队头元素



## priority_queue

优先队列，默认为大根堆。

- size()
- empty()
- push()：插入一个元素
- top()：返回堆顶元素
- pop()：弹出堆顶元素

改为小根堆，两种方法：

1. 将x变为-x插入。
2. piority_queue<int, vector<int>, greater<int>> q;



## stack

栈

- size()
- empty()
- push()：向栈顶插入一个元素
- top()：返回栈顶元素
- pop()：弹出栈顶元素

没办法返回栈底元素，除非自己数组实现。



## deque

双端队列

功能强大

效率较低，不常用

- size()
- empty()
- clear()
- front() / back()
- push_back() / pop_back()
- push_front() / pop_front()
- begin() / end()
- []



## set, multiset, map, multimap

基于平衡二叉树（红黑树），动态维护有序序列。

- size()

- empty()

- clear()

- begin() / end()  可++, --, 返回前驱、后缀，时间复杂度为O(logn)

  set / multiset

- insert()：插入一个数

- find()：查找一个数

- count()：返回某一个数的个数

- erase()

  - 输入为一个数x，则删除所有x。O(k + logn)k为x的个数
  - 输入为一个迭代器，则删除这个迭代器。

- lower_bound() / upper_bound()

  - lower_bound(x)：返回大于等于x的最小元素
  - upper_bound(x)：返回大于x的最小元素

  map / multimap

- insert()：输入的参数是一个pair

- find()

- erase()：输入的参数是pair或迭代器

- []   时间复杂度是O(logn)

- lower_bound() / upper_bound()



## unordered_set, unordered_multiset, unordered_map, unordered_multimap

基于哈希表实现，和上面类似，增删改查的时间复杂度是O(1)，不支持 lower_bound() / upper_bound()



## pair

相当于自带比较运算的结构体。

例如，pair<int, int>

- first：第一个元素
- second：第二个元素
- 支持比较运算（字典序）

pair<int, pair<int, int>>：可以类似这样套娃，装下n个元素。



## bitset

压位

- 初始化

  - bitset<10000> s;

- ~, &, |, ^：取反，与运算，或运算，取负数

- <<, >> ：左移，右移

- ==, !=

- []

- count()：返回有多少个1。

  

- any()：判断是否至少有一个1。

- none()：判断是否没有1。

  

- set()：把所有位变成1。

- set(k, v)：把第k位变成v。

- reset()：把所有位变成0。

- flip()：等价于~。

- flip(k)：把第k位取反。
