---
layout:     post
title:      AcWing基础算法-数据结构（一）
subtitle:   AcWing基础算法碎碎念
date:       2021-02-21
author:     小熊pink
header-img: img/the-first.png
catalog:   true
tags:
    - AcWing基础算法
---
# 单链表

### 实现

用数组实现：（算法竞赛中，偏向于用数组；工程里，一般用结构体/class等new，有O2/O3优化）

- 优点：运算速度快；可记录第k个插入的数；结构体等可以做的，数组都可以做。

- 缺点：remove后，未重复利用空间；空间有限。

head：头部，记录头部所指节点的下标。初始化为-1，即指向空节点。(int型)

e[n]：下标为n的节点所包含的元素。（任意类型数组）

ne[n]：next指针，下标为n的节点所指向的下一个节点下标。（int型数组）

idx：当前可用的新节点下标。初始化为0。（int型）



### 操作

- 增

  - 头部后增加新节点

    ```c++
    void add2head(int x)
    {
        e[idx] = x;
        ne[idx] = head;
        head = idx;
        ++ idx;
    }
    ```

  - 某节点后增加新节点

    ```c++
    void add(int k, int x)
    {
        e[idx] = x;
        ne[idx] = ne[k];
        ne[k] = idx;
        ++ idx;
    }
    ```

- 删

  ```c++
  if(k) ne[k - 1] = ne[ne[k - 1]];
  else head = ne[head];
  ```

# 双链表

### 实现

用数组实现：

数组表示优缺点同单链表。

head：头部的下标。初始化为0。（int型）同时，初始化r[head] = 1，即向右指向尾部。

tail：尾部的下标。初始化为1。（int型）同时，初始化l[tail] = 0，即向左指向头部。

e[n]：下标为n的节点所包含的元素。（任意类型数组）

l[n]：左指针，下标为n的节点所指向的左边的节点下标。（int型数组）

r[n]：右指针，下标为n的节点所指向的右边的节点下标。（int型数组）

idx：当前可用的新节点下标。初始化为2。（int型）



### 操作

- 增

  - 头部右边增加新节点

    ```c++
    scanf("%d", &x);
    e[idx] = x;
    l[idx] = head;
    r[idx] = r[head];
    r[l[idx]] = idx;
    l[r[idx]]
    ```

  - 尾部左边增加新节点

    ```c++
    scanf("%d", &x);
    e[idx] = x;
    l[idx] = l[tail];
    r[idx] = tail;
    r[l[idx]] = idx;
    l[r[idx]] = idx;
    ++ idx;
    ```

  - 某节点左边增加新节点

    ```c++
    scanf("%d%d", &k, &x);
    e[idx] = x;
    l[idx] = l[k + 1];
    r[idx] = k + 1;
    l[r[idx]] = idx;
    r[l[idx]] = idx;
    ++ idx;
    ```

  - 某节点右边增加新节点

    ```c++
    scanf("%d%d", &k, &x);
    e[idx] = x;
    l[idx] = k + 1;
    r[idx] = r[k + 1];
    l[r[idx]] = idx;
    r[l[idx]] = idx;
    ++ idx;
    ```

- 删

  ```c++
  scanf("%d", &k);
  l[r[k + 1]] = l[k + 1];
  r[l[k + 1]] = r[k + 1];
  ```

# 栈

先进后出。

### 实现

用数组实现：

stk[n]：下标为n的节点所包含的元素。（任意类型数组）

tt：栈顶下标。（int类型数组）



### 操作

- 压入栈顶

  ```c++
  scanf("%d", &x);
  stk[tt ++ ] = x;
  ```

- 弹出栈顶

  ```c++
  -- tt;
  ```

- 获得栈顶

  ```c++
  printf("%d\n", stk[tt - 1]);
  ```

- 判断是否为空

  ```c++
  if(tt) printf("NO\n");
  else printf("YES\n");
  ```

# 队列

先进先出。

### 实现

用数组实现：

e[n]：下标为n的节点所包含的元素。（任意类型数组）

hh：队头下标。初始化为0。（int型）

tt：队尾下标。初始化为-1。（int型）



### 操作

- 添加队尾

  ```c++
  scanf("%d", &x);
  q[++ tt] = x;
  ```

- 删除队头

  ```c++
  ++ hh;
  ```

- 获取对头

  ```c++
  printf("%d\n", q[hh]);
  ```

- 获取队尾（数组好处）

- 判断是否空

  ```c++
  if(hh <= tt) printf("NO\n");
  else printf("YES\n");
  ```

# 单调栈

经典例题：给出一个数列，求出每个数左边离它最近的、比它小/大的数。

先思考朴素/暴力做法，再看之中的规律得到优化解法。



# 单调队列

经典例题：有长度为k的滑动窗口，从左到右在一个数列(n>k)中滑动，求出每个窗口中，最小/最大的数。

先思考朴素/暴力做法，再看之中的规律得到优化解法。



# KMP

给出模板p[N]和需要进行匹配的s[M]，求出s[M]中可以被p[N]匹配的起始坐标（从0开始）。

先思考朴素/暴力做法，再看之中的规律得到优化解法。

i为s[M]上的指针，指向s[M]中准备匹配元素的下标。初始化为1。

j为p[N]上的指针，指向p[N]中匹配完毕元素的下标，即p[j + 1]为准备匹配的元素的下标。初始化为0。

ne[n]：p[N]中以下标为n的地方结尾的，符合最长匹配的后缀的，p[N]中下一个的下标。

