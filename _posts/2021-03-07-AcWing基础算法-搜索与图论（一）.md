---
layout:     post
title:      AcWing基础算法-搜索与图论（一）
subtitle:   AcWing基础算法碎碎念
date:       2021-03-07
author:     小熊pink
header-img: img/the-first.png
catalog:   true
tags:
    - AcWing基础算法
---
# DFS

深度优先搜索。

存储空间为搜索树的高度。

没有最短路性质。

**实现**

栈

回溯要还原现场

**应用**

- 全排

  ```c++
  int n;
  int q[10];
  bool st[10];
  
  void dfs(int u)
  {
      if(u == n)
      {
          for(int i = 0; i < n; ++ i) printf("%d ", q[i]);
          puts("");
          return;
      }
  
      for(int i = 0; i < n; ++ i)
      {
          if(!st[i])
          {
              q[u] = i + 1;
              st[i] = 1;
              dfs(u + 1);
              st[i] = 0;
          }
      }
  }
  ```

  

# BFS

广度优先搜索。

存储空间为整个搜索树的节点。

有最短路性质。

**实现**

队列（q[N], hh, tt）

模板：

```
queue <- 1 \\在队头放入元素。
while(queue非空)
{
	t = 队头 \\把队头取出
	拓展t
}
```

**应用**

- 权为1的最短路问题

# 树与图的存储

树是一种特殊的图（有向无环图），因此也可以用图的存储形式存储。

图可分为有向图与无向图，而无向图也可以看作有向图，因此图的存储形式只要掌握有向图的存储。

有向图有两种存储方式：

1. 邻接矩阵（有权用int，无权用bool / 0,1）（不常用）
2. 邻接表（一般不在意顺序）（常用）

**邻接表实现**

h[N]：表头。初始化为-1。

e[2 * N]：下标为k的链表节点所存储的图节点。

ne[2 * N]：下标为k的链表节点的next指针，指向下一个链表节点下标。

idx：当前可用链表节点的下标。

**操作**

- 加一条由节点a指向节点b的边

  ```c++
  e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
  ```

  

# 树与图的DFS



# 树与图的BFS



# 拓扑排序

利用入度使用BFS，逐个拆解，最后可输出拓扑序列。
