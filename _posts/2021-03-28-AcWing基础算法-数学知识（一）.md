---
layout:     post
title:      AcWing基础算法-数学知识（一）
subtitle:   AcWing基础算法碎碎念
date:       2021-03-28
author:     小熊pink
header-img: img/the-first.png
catalog:   true
tags:
    - AcWing基础算法
---
## 质数

### 质数判定——试除法

O(sqrt(n)),  若为质数则一定为sqrt(n)，否则小于

质数：$\geq2$ 的整数，且因数只有1与自身。

d|n <=>  $\frac{n}{d}$|n   ==>   从2开始枚举到d $\leq$ n/d 即可

```c++
bool isPrime(int n)
{
    if(n < 2) return false; //一定要判定这个
    for(int i = 2; i <= n / i; ++ i)
        if(n % i == 0) return false;
    return true;
}
```



### 分解质因数——试除法

O(sqrt(n)), 通常小于sqrt(n)，比如$2^m$可用logn

n中最多只含有一个大于sqrt(n)的质因数，
否则两质因数相乘大于n

==> 从2开始枚举到d $\leq$ n/d，其中会更新n

此过程可确保每次枚举为质因子，因为合数因子已被该合数前的质因子清除。

```c++
void prime_divisor(int n)
{
    for(int i = 2; i <= n / i; ++ i)
        if(n % i == 0)
        {
            int s = 0;
            while(n % i == 0)
            {
                ++ s;
                n /= i;
            }
            printf("%d %d\n", i, s);
        }
    if(n > 1) printf("%d %d\n", n, 1);
    puts("");
}
```



### 筛质数

把2~n内所有合数筛掉，筛出所有质数。

#### 朴素做法

从小到大遍历数，用数的倍数筛

```c++
int n, res;
bool st[N];

void filter(int n)
{
    for(int i = 2; i <= n; ++ i)
    {
        if(!st[i]) ++ res;
        for(int j = i + i; j <= n; j += i) st[j] = 1;
    }
}
```



#### 埃氏筛法

从小到大遍历质数，用质数的倍数筛

```c++
int n, res;
bool st[N];

void filter(int n)
{
    for(int i = 2; i <= n; ++ i)
        if(!st[i])
        {
            ++ res;
            for(int j = i + i; j <= n; j += i) st[j] = 1;
        }
}
```



#### 线性筛法

从小到大遍历倍数，再遍历可能的最小质因子，用最小质因子的倍数筛

```c++
int n, res;
int prime[N];
bool st[N];

void filter(int n)
{
    for(int i = 2; i <= n; ++ i)
    {
        if(!st[i]) prime[res ++] = i;
        for(int j = 0; prime[j] <= n / i; ++ j)
        {
            st[prime[j] * i] = 1;
            if(i % prime[j] == 0) break;
        }
    }
}
```



## 约数

### 求约数——试除法

O(sqrt(n))

与质数判定类似，最后加上1与自身。

```c++
void all_divisor(int n)
{
    int idx = 0;
    for(int i = 1; i <= n / i; ++ i)
        if(n % i == 0)
        {
            s[idx ++] = i;
            if(i != n / i) s[idx ++] = n / i;
        }
    sort(s, s+idx);
    for(int i = 0; i < idx; ++ i) printf("%d ", s[i]);
    puts("");
}
```



### 约数个数

任意数k：

$k=p_1^{\alpha_1}p_2^{\alpha_2}...p_m^{\alpha_m}$

$p_i$: 质数

$\alpha_i$: 质数的指数，$\geq0$

根据排列组合，约数个数为：$(\alpha_1+1)(\alpha_2+1)...(\alpha_m+1)$

```c++
unordered_map<int, int> q;

void cnt(int n) //求所有质因数个数
{
    for(int i = 2; i <= n / i; ++ i)
        while(n % i == 0)
        {
            ++ q[i];
            n /= i;
        }
    if(n > 1) ++ q[n];
}

LL res = 1;
for(auto t: q) res = res * (t.second + 1) % mod;
printf("%lld", res);
```



### 约数之和

约数之和为：$(p_1^{0}+p_1^{1}+...+p_1^{\alpha_1})(p_2^{0}+p_2^{1}+...+p_2^{\alpha_2})...(p_m^{0}+p_m^{1}+...+p_m^{\alpha_m})$

```c++
unordered_map<int, int> q;

void cnt(int n)
{
    for(int i = 2; i <= n / i; ++ i)
        while(n % i == 0)
        {
            ++ q[i];
            n /= i;
        }
    if(n > 1) ++ q[n];
}

LL res = 1;
for(auto t: q)
{
    LL a = 1;
    for(int i = 0; i < t.second; ++ i)
        a = (a * t.first + 1) % mod;
    res = res * a % mod;
}
printf("%lld", res);
```



### 最大公约数——欧几里得算法

也叫辗转相除法。一般不用更相减损法。

核心思想：$(a,b)$ <=> $(b,a \% b)$

若d为a与b的因数，则d一定为b与a%b的因数；反之也对。

直到b==0, a即为最大公约数。

```c++
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```
