---
layout:     post
title:      AcWing基础算法-搜索与图论（三）
subtitle:   AcWing基础算法碎碎念
date:       2021-03-11
author:     小熊pink
header-img: img/the-first.png
catalog:   true
tags:
    - AcWing基础算法
---

## 最小生成树

一般从无向图中寻找。

### Prim算法 

(普利姆算法)

Prim算法可分为朴素版Prim算法O(n^2)，与堆优化版Prim算法O(mlogn)。

稠密图使用朴素版Prim算法；稀疏图一般不使用较复杂的堆优化版Prim算法，而使用Kruskal算法。

这里介绍朴素版Prim算法。



**实现**

- g[N] [N]
- dist[N]
- st[N]：是否在集合中
- res：树的边权之和



**步骤**

初始化所有点离集合的距离为正无穷

循环n次
	找到离集合最近的点t
	若t不为第一次找的点 且 最近距离为正无穷
		无法生成树	
	否则
	将t加入集合
	将该最近距离加入res
	更新与t相连的其他点到集合的最近距离



**代码**

```c++
bool prim()
{
    for(int i = 0; i < n; ++ i)
    {
        int t = 0;
        for(int j = 1; j <= n; ++ j)
            if(!st[j] && (!t || dist[t] > dist[j])) t = j;
        if(i && dist[t] == 0x3f3f3f3f) return false;
        if(i) res += dist[t];
        st[t] = 1;
        for(int j = 1; j <= n; ++ j)
            dist[j] = min(dist[j], g[t][j]);
    }
    return true;
}

int main()
{
    memset(dist, 0x3f, sizeof dist);
    memset(g, 0x3f, sizeof g);
    scanf("%d%d", &n, &m);
    while(m --)
    {
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        g[a][b] = g[b][a] = min(g[a][b], w);
    }
    if(prim()) printf("%d\n", res);
    else puts("impossible");
}
```



### Kruskal算法

（库鲁斯克尔算法）

O(mlogm)



**实现**

- struct edges[M]：存储a, b, w
  重载<运算符
- res：树的边权之和
- sum：已加入边数
- p[N]：并查集



**步骤**

将所有边按照权重从小到大排序 O(mlogm)

遍历排序后的边
	若该边两点不连通
		res += w
		连通两点
		++ s

若s < n - 1
	无法生成树
否则
	找到最小生成树



**代码**

```c++
int n, m;
int p[N];
struct Edge{
    int a, b, w;
    bool operator< (const Edge& e) const
    {
        return w < e.w;
    }
}edges[M];

int find(int x)
{
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; ++ i) p[i] = i;
    for(int i = 0; i < m; ++ i) //要用m,不能while(m --)了
    {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        edges[i] = {x, y, z};
    }
    sort(edges, edges + m);
    int res = 0, sum = 0;
    for(int i = 0; i < m; ++ i)
    {
        int a = find(edges[i].a), b = find(edges[i].b), w = edges[i].w;
        if(a != b)
        {
            res += w;
            p[a] = b;
            ++ sum;
        }
    }
    if(sum < n - 1) puts("impossible");
    else printf("%d", res);
}
```



## 二分图划分判定

二分图 <==>图内无奇数环

### 染色法

在互不连通的图中依次染色，
若出现矛盾（有奇数环），则无法划分为二分图；否则可以划分为二分图。



**实现**

- color[N]
- bool dfs(int x, int c)
- 邻接表 / 邻接矩阵



**步骤**

遍历所有点
	若没颜色
		用dfs()染色
			若出现矛盾
				不可划分为二分图
若一直无矛盾
	可以划分为二分图



**核心步骤**

dfs()

遍历该点相连的其他点
	若没颜色
		dfs()染色。若为false，返回false
	若有颜色且出现矛盾
		返回false

返回true

```C++
bool dfs(int x, int c)
{
    color[x] = c;
    for(int i = h[x]; ~i; i = ne[i])
    {
        int k = e[i];
        if(!color[k])
        {
            if(!dfs(k, 3 - c)) return false;
        }
        else if(x != k && color[k] == c) return false;
    }
    return true;
}
```

**代码**

```C++
bool flag = 1;
for(int i = 1; i <= n; ++ i)
{
    if(!color[i])
    {
        if(!dfs(i, 1))
        {
            flag = 0;
            break;
        }
    }
}
if(flag) puts("Yes");
else puts("No");
```



## 二分图的最大匹配数

### 匈牙利算法

类似于给男女当月老。执着于给男生牵线，直到化解矛盾，否则放弃牵线。

**实现**

- h[N], e[M], ne[M], idx：存储男生所有可能牵线的对象
- match[N]：目前女生牵线的对象
- st[N]：给每位男生选择时判重，否则会陷入死循环
- find()
- res



**核心步骤**

```c++
bool find(int x)
{
    for(int i = h[x]; ~i; i = ne[i])
    {
        int k = e[i];
        if(!st[k])
        {
            st[k] = 1;
            if(!match[k] || find(match[k]))
            {
                match[k] = x;
                return true;
            }
        }
    }
    return false;
}
```



**代码**

```c++
int res = 0;
for(int i = 1; i <= n1; ++ i)
{
    memset(st, 0, sizeof st);
    if(find(i)) ++ res;
}
printf("%d", res);
```
