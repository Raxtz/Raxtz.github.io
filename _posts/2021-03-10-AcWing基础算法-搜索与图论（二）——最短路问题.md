---
layout:     post
title:      AcWing基础算法-搜索与图论（二）——最短路问题
subtitle:   AcWing基础算法碎碎念
date:       2021-03-10
author:     小熊pink
header-img: img/the-first.png
catalog:   true
tags:
    - AcWing基础算法
---
## 方法总结

n：节点数
m：边数



最短路问题

- 单源最短路问题
  - 边权为正值
    - 稠密图（m ~ n^2）
      朴素Dijkstra算法   **O(n^2)**   [邻接矩阵]
    - 稀疏图（m ~ n）（此时也可考虑spfa，但可能被卡）
      堆优化版Dijkstra算法   **O(mlogn)**   [邻接表]
  - 存在负权边（可有负权回路，以下算法均可判断）
    - 限制经过边数
      Bellman-Ford算法   **O(nm)**   [结构体]
    - 不限制经过边数
      SPFA算法   **一般O(m)，最坏O(nm)**   [邻接表/邻接矩阵]
- 多源汇最短路问题（可存在负权边）（可判断负权回路吗？感觉用cnt可以？）
  - Floyd算法    **O(n^3)**   [邻接矩阵]



## 朴素Dijkstra算法

单源 正权稠密图。O(n^2)



**实现**

- 邻接矩阵—稠密图
- dist[N]



**步骤**

初始化源点的dist为0，其余为INF（可用0x3f3f3f3f）

n次循环：
	每次取不在S集合中dist最小的值t
	t放入S集合中
	更新与t相接的其他点



**代码**

```c++
int n, m;
int g[N][N];
int dist[N], s[N];

int dijkstra()
{
    dist[1] = 0;
    for(int i = 0; i < n; ++ i)
    {
        int t = 0;
        for(int j = 1; j <= n; ++ j)
            if(!s[j] && (!t || dist[j] < dist[t])) t = j;
        s[t] = 1;
        for(int j = 1; j <= n; ++ j)
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    }
    if(dist[n] == 0x3f3f3f3f) return -1;
    else return dist[n];
}

int main()
{
    memset(g, 0x3f, sizeof g);
    memset(dist, 0x3f, sizeof dist);
    scanf("%d%d", &n, &m);
    while(m --)
    {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        g[x][y] = min(g[x][y], z);
    }

    cout << dijkstra() << endl;
}
```



## 堆优化版Dijkstra算法

单源 正权稀疏图。O(mlogn)



**实现**

- 邻接表—稀疏图
- 优先队列的小根堆
- dist[N]



**步骤**

初始化源点的dist为0，其余为INF（可用0x3f3f3f3f）

n次循环：
	每次从堆中取不在S集合中dist最小的值t
	t放入S集合中
	更新与t相接的其他点，并放入堆中



**代码**

```c++
int n, m;
int h[N], e[N], ne[N], w[N], idx;
int dist[N];
bool s[N];
priority_queue<PII, vector<PII>, greater<PII>> q;

int dijkstra()
{
    dist[1] = 0;
    q.push({0, 1});
    while(q.size())
    {
        PII t = q.top();
        q.pop();
        if(s[t.second]) continue;
        s[t.second] = 1;
        for(int i = h[t.second]; i != -1; i = ne[i])
        {
            int k = e[i];
            if(dist[k] > t.first + w[i])
            {
                dist[k] = t.first + w[i];
                q.push({dist[k], k});
            }
        }
    }
    if(dist[n] == 0x3f3f3f3f) return -1;
    else return dist[n];
}

int main()
{
    memset(h, -1, sizeof h);
    memset(dist, 0x3f, sizeof dist);
    scanf("%d%d", &n, &m);
    while(m --)
    {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        e[idx] = y, ne[idx] = h[x], w[idx] = z, h[x] = idx ++;
    }
    cout << dijkstra() << endl;

}
```



## Bellman-Ford算法

单源 有负权或负环且边数限制的图。O(nm)



**实现**

- 结构体—图的m条边（a, b, w）
- dist[N]



**步骤**

循环k次（k为限制的边数）（一般情况用n，则第n次判断有更新则存在负权边）
	**备份dist[N]为temp[N]**（避免串联情况）
	对于每个边m（a-->b）
		dist[b] = min(temp[b], temp[a] + w)



**代码**

```c++
int n, m, k;
int dist[N], temp[N], idx;

struct edge{
    int a, b, w;
} edges[M];

int main()
{
    scanf("%d%d%d", &n, &m, &k);
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    while(m --)
    {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        edges[idx].a = x;
        edges[idx].b = y;
        edges[idx].w = z;
        ++ idx;
    }
    while(k --)
    {
        memcpy(temp, dist, sizeof dist);
        for(int i = 0; i < idx; ++ i)
            dist[edges[i].b] = min(dist[edges[i].b], temp[edges[i].a] + edges[i].w);
    }
    if(dist[n] > 0x3f3f3f3f / 2) cout << "impossible" << endl;
    else cout << dist[n] << endl;
}
```



## SPFA算法

单源 有负权或负环且无边数限制的图。一般O(m)，最坏O(nm)



**实现**

- 邻接表/邻接矩阵—稀疏图/稠密图
- dist[N]
- 队列
- st[N]



**步骤**

将源点放入队列中

while（队列不为空）
	t <-- 队头
	if(t相接的节点可更新)
	{
		更新
		if(更新节点不在队列中) 放入队列
	}



**代码**

```c++
int n, m;
int h[N], e[N], ne[N], w[N], idx;
int dist[N];
int q[N], hh, tt;
bool st[N];

int main()
{
    scanf("%d%d", &n, &m);
    memset(dist, 0x3f, sizeof dist);
    memset(h, -1, sizeof h);
    while(m --)
    {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        e[idx] = y, ne[idx] = h[x], w[idx] = z, h[x] = idx ++;
    }
    q[0] = 1;
    dist[1] = 0;
    st[1] = 1;
    while(hh <= tt)
    {
        int t = q[hh ++];
        st[t] = 0;
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int k = e[i];
            if(dist[k] > dist[t] + w[i])
            {
                dist[k] = dist[t] + w[i];
                if(!st[k])
                {
                    st[k] = 1;
                    q[++ tt] = k;
                }
            }
        }
    }
    if(dist[n] > 0x3f3f3f3f / 2) cout << "impossible" << endl;
    else cout << dist[n] << endl;
}
```



**判断有无负环的代码**

```c++
int n, m;
int cnt[N];
int h[N], e[M], ne[M], w[M], idx;
int dist[N];
queue<int> q;
bool st[N];

bool spfa()
{
    for(int i = 1; i <= n; ++ i)
    {
        q.push(i);
        st[i] = 1;
    }
    while(q.size())
    {
        int t = q.front();
        q.pop();
        st[t] = 0;
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int k = e[i];
            if(dist[k] > dist[t] + w[i])
            {
                dist[k] = dist[t] + w[i];
                cnt[k] = cnt[t] + 1;
                if(cnt[k] >= n) return true;
                if(!st[k])
                {
                    st[k] = 1;
                    q.push(k);
                }
            }
        }
    }
    return false;
}

int main()
{
    memset(h, -1, sizeof h);
    scanf("%d%d", &n, &m);
    while(m --)
    {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        e[idx] = y, ne[idx] = h[x], w[idx] = z, h[x] = idx ++;
    }
    if(spfa()) cout << "Yes" << endl;
    else cout << "No" << endl;
}
```



## Floyd算法

多源汇 图。O(n^3)



**实现**

- 邻接矩阵
- d[N] [N]



**步骤**

第一层循环必须为k，第二三层任意

for(int k = 1; k <= n; ++ k)
	for(int i = 1; i <= n; ++ i)
		for(int j = 1; j <= n; ++ j)
			d[i] [j] = min(d[i] [j], d[i] [k] + d[k] [j])

**代码**

```c++
int n, m, t;
int g[N][N];

int main()
{
    memset(g, 0x3f, sizeof g);
    scanf("%d%d%d", &n, &m, &t);
    for(int i = 1; i <= n; ++ i) g[i][i] = 0;
    while(m --)
    {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        g[x][y] = min(g[x][y], z);
    }
    for(int k = 1; k <= n; ++ k)
        for(int i = 1; i <= n; ++ i)
            for(int j = 1; j <= n; ++ j)
                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
    while(t --)
    {
        int a, b;
        scanf("%d%d", &a, &b);
        if(g[a][b] > 0x3f3f3f3f / 2) puts("impossible");
        else cout << g[a][b] << endl;
    }
}
```

