---
layout:     post
title:      AcWing基础算法-基础算法（三）
subtitle:   AcWing基础算法碎碎念
date:       2021-02-18
author:     小熊pink
header-img: img/the-first.png
catalog:   true
tags:
    - AcWing基础算法
---

# 双指针算法

大致可分为两类：

1. 两个指针分别操作一个序列（如，归并排序）
2. 两个指针共同操作一个序列（如，快速排序）

通常，有个第二类的使用模板：

```c++
for(int i = 0; i <= n; ++ i)
{
	while(j <= i && check(i, j)) ++ j;
	
	//各题对应操作
}
```

（有些题中，j有单调性，只会右移。）

# 位运算

1. 求整数n的二进制表达中第k位的数。

   ```c++
   n >> k & 1
   ```

2. 自定义lowbit()函数，返回x二进制表示的最右侧1及右边数所代表的数。

   具体实现：

   ```c++
   x & -x
   //也可以写为
   x & (~x + 1)
   ```

   作用：帮助计算整数n二进制表示中1的个数。

# 离散化

将比起整数取值范围来说，个数不多的整数（如取数范围1e9，但个数1e5，量级相差明显），映射至0，1，2，3，... 或1，2，3，4，...

作用：减少空间复杂度

1. 对数组进行排序+去重。

   ```c++
   vector<int> alls;
   sort(alls.begin(), alls.end());//排序//sort函数在algorithm中
   alls.erase(unique(alls.begin(), alls.end()), alls.end());//排序后去重
   
   //unique函数在头文件<algorithm>中
   //unique函数将重复元素全部放到容器末尾，并返回去重后的尾地址（即重复元素区间的第一个位置）
   
   //若无unique函数，排序后可用双指针算法去重：
   vector<int>::iterator uni(vector<int> &alls)
   {
       vector<int>::iterator j = alls.begin();
       for(int i = 0; i < alls.size(); ++ i)
       {
           if(!i || alls[i] != alls[i - 1]) alls[j ++] = alls[i];
       }
       return j;
   }
   ```

2. 寻找离散化后的下标——二分。

   ```c++
   return l; //0, 1, 2, ...
   return l + 1; //1, 2, 3, ...
   ```

# 区间合并

将具有交集的区间合并，返回合并后区间个数。

1. 根据区间左端点位置，排序。
2. 从左往右，根据每个区间左端点位置判断，处理区间：
   - 扩大处理区间
   - 解决处理完毕区间，处理下一个区间
