---
layout:     post
title:      AcWing基础算法-数据结构（二）
subtitle:   AcWing基础算法碎碎念
date:       2021-02-25
author:     小熊pink
header-img: img/the-first.png
catalog:   true
tags:
    - AcWing基础算法
---
# Trie

**作用：**存储与查找一串 由有限种字符组成的 字符串/编码

**实现：**

由两个数组实现树的结构。

M：有限种字符的个数。

L：字符串的平均/最大长度。

N：大致为总节点个数，M^L。

son[N] [M]：若数值不为0，则说明已启用。初始化为0。（son[0] [M]表示根节点与第一个字符的关系）

cnt[N]：记录以该字符结尾的字符串个数。初始化为0。

idx：启用新节点，占用N。



### 操作

1. 存储

   ```c++
   //有限元素为26个小写字母
   int t = 0;
   for(int i = 0; str[i]; ++ i)
   {
   	int u = str[i] - 'a';
   	if(!son[t][u]) son[t][u] = ++ idx;
   	t = son[t][u];
   }
   ++ cnt[t];
   ```

2. 查找

   ```c++
   //有限元素为26个小写字母
   int t = 0, ed = 1;
   for(int i = 0; str[i]; ++ i)
   {
   	int u = str[i] - 'a';
   	if(!son[t][u])
   	{
   		printf("0\n");
   		ed = 0;
   		break;
   	}
   	t = son[t][u];
   }
   if(ed) printf("%d\n", cnt[t]);
   ```



# 并查集

**作用：**

1. 将两个集合合并为同一个集合。

2. 查找两个元素是否属于同一个集合。

   自行添加：

3. 查找某元素所在的集合中元素个数。

**实现：**

用数组实现树的结构。

p[N]：某元素的父节点。初始化为元素本身数值。

自行添加：

size[N]：某元素所在集合的元素个数。初始化为1。

**优化：**

1. 路径压缩（常用）
2. 按秩合并（很废）

### 核心操作

find()

```C++
//使用路径压缩
int find(int x)
{
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}
```



### 应用操作

1. 将两个集合合并为同一个集合。

   ```C++
   p[find(a)] = find(b)
   ```

2. 查找两个元素是否属于同一个集合。

   ```c++
   if(find(a) == find(b)) puts("Yes");
   else puts("No");
   ```

   自行添加：

3. 查找某元素所在的集合中元素个数。

   ```c++
   //添加
   int s[N];
   //初始化
   for(int i = 1; i <= n; ++ i) s[i] = 1;
   //合并集合改为
   int x1 = find(a), x2 = find(b);
   if(x1 != x2)
   	{
   		p[x1] = x2;
   		s[x2] += s[x1];
   	}
   //查找元素个数
   printf("%d\n", s[find(a)]);
   ```



# 堆

**作用：**

1. 向集合中插入一个元素

2. 输出集合中的最小值/最大值

3. 删除集合中的最小值/最大值

   自行添加：

4. 删除集合中的任意一个元素

5. 修改集合中的任意一个元素

**实现：**

用数组实现完全二叉树的结构。

N：集合最大元素个数。

h[N]：储存该节点的元素。

size：集合元素个数。

（$2x$为左子节点，$2x+1$为右子节点；相反，x/2为父节点）



如果要记住第k个插入的数，并对其删除/修改，需要引入：

ph[N]：第k个插入对应的下标x

hp[N]：下标x对应的第k个插入

t：第几个插入



### 核心操作

以min heap为例

1. down()

   ```c++
   void down(int x) //如果要记住第k个插入的数，用h_swap()，否则用swap()
   {
       int u = x;
       while(1)
       {
           int x1 = 2 * x, x2 = 2 * x + 1;
           if(x1 <= s && h[x1] < h[u]) u = x1; 
           if(x2 <= s && h[x2] < h[u]) u = x2; //这里要和h[u]比较
           if(x != u) h_swap(x, u);
           else return;
           x = u;
       }
   }
   ```

2. up()

   ```c++
   void up(int x) //如果要记住第k个插入的数，用h_swap()，否则用swap()
   {
       int u = x >> 1;
       while(1)
       {
           if(u > 0 && h[u] > h[x]) h_swap(x, u);
           else return;
           x = u;
           u /= 2;
       }
   }
   ```

3. h_swap()

   ```c++
   void h_swap(int x, int u)
   {
       swap(h[x], h[u]);
       swap(ph[hp[x]], ph[hp[u]]);
       swap(hp[x], hp[u]);
   }
   ```

   

### 应用操作

以min heap为例，且需记住第k个插入的元素

1. 向集合中插入一个元素

   ```c++
   scanf("%d", &x);
   h[++s] = x;
   ph[++ t] = s;
   hp[s] = t;
   up(s);
   ```

2. 输出集合中的最小值/最大值

   ```c++
   printf("%d\n", h[1]);
   ```

3. 删除集合中的最小值/最大值

   ```c++
   h_swap(1, s);
   -- s;
   down(1);
   ```

   自行添加：

4. 删除集合中的任意一个元素

   ```c++
   //删除第k个插入的元素
   scanf("%d", &k);
   int u = ph[k];
   h_swap(u, s);
   -- s;
   up(u);
   down(u);
   ```

5. 修改集合中的任意一个元素

   ```C++
   //删除第k个插入的元素
   scanf("%d%d", &k, &x);
   h[ph[k]] = x;
   down(ph[k]);
   up(ph[k]);
   ```
